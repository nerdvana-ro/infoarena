#! /usr/bin/env php
<?php

require_once __DIR__ . '/../Config.php';

require_once(Config::ROOT.'common/log.php');
require_once(Config::ROOT.'common/common.php');

require_once(Config::ROOT.'common/score.php');
require_once(Config::ROOT.'common/task.php');
require_once(Config::ROOT.'common/round.php');
require_once(Config::ROOT.'common/db/task.php');
require_once(Config::ROOT.'common/db/job.php');
require_once(Config::ROOT.'common/db/user.php');
require_once(Config::ROOT.'common/db/task_statistics.php');

require_once(Config::ROOT.'eval/Exceptions.php');
require_once(Config::ROOT.'eval/ClassicJudge.php');

require_once __DIR__ . '/../lib/Core.php';

error_reporting(0xFFFF);

// Must be less than MySQL's wait_timeout value.
const SQL_SESSION_TIMEOUT = 7200; // seconds
$connectedSince = time();

// Resets the ORM connection periodically.
function reconnect_if_needed() {
  global $connectedSince;

  $ts = time();
  if ($ts - $connectedSince > SQL_SESSION_TIMEOUT) {
    log_print('Reconnecting to database since more than ' . SQL_SESSION_TIMEOUT
              . ' seconds have elapsed.');
    ORM::reset_db();
    $connectedSince = $ts;
  }
}

// Send job result.
function job_send_result(int $jobId, EvalResult $res): void {
  log_print("Sending result for job #{$jobId} ".
            "score {$res->score} message {$res->message}");
  log_print("");
  job_update($jobId, 'done', $res->message, $res->log, $res->score,
             $res->getMaxTime(), $res->getMaxMemory());
}

// This function handles a certain job.
function job_handle($job) {
  reconnect_if_needed();

  $job = Job::get_by_id($job['id']);
  $job->status = 'processing';
  $job->save();

  $task = $job->getTask();
  log_assert($task, "Nu am găsit task-ul {$job->task_id}.");

  log_print("Job #{$job->id} task {$task->id} round {$job->round_id} type {$task->type}");
  if ($task->type == 'classic') {
    $judge = new ClassicJudge($job, $task);
  } else {
    log_error("Nu știu să evaluez task-uri de tip {$task->type}.");
  }

  try {
    $evalResult = $judge->run();
  } catch (EvalException $e) {
    $evalResult = new EvalResult();
    $evalResult->message = $e->getShortMessage();
    $evalResult->log = $e->getMessage();
  }

  $submit_count = 0;
  /**
   * Check if the task was in a penalty type round
   * Also increase the submit_count
   */
  if ($job->round_id) {
    $round = round_get($job->round_id);
    if ($round['type'] == 'penalty-round') {
      $round_parameters = round_get_parameters($job->round_id);
      /*
       * Check the number of submits (so we can add to penalty)
       */
      if ($evalResult->score > 0) {
        $percent = max($round_parameters['minimum_score'], 100 -
                       $job->submissions * $round_parameters['submit_cost'] -
                       (int)((db_date_parse($job->submit_time) -
                              db_date_parse($round['start_time'])) /
                             $round_parameters['decay_period']));
        $evalResult->score = (int)($percent * $evalResult->score / 100);
      }
    }
  }

  // Send job result and update score magic.
  job_send_result($job->id, $evalResult);
  score_update_for_job(
    $evalResult->score,
    $job->submit_time,
    $job->user_id,
    $job->task_id,
    $job->round_id
  );

  task_update_solved_by(
    $job->task_id,
    $job->user_id
  );
}

// Main loop. It works by polling the SQL server.
function eval_main_loop() {
  db_connect();

  log_print("");
  log_print("Eval started");
  log_print("");

  while (1) {
    if ($round = round_get_round_to_wait()) {
      round_event_wait($round);
      continue;
    }
    if ($round = round_get_round_to_start()) {
      round_event_start($round);
      continue;
    }
    if ($round = round_get_round_to_stop()) {
      round_event_stop($round);
      continue;
    }
    if ($job = job_get_next_job()) {
      job_handle($job);
      continue;
    }
    usleep(Config::EVAL_POLL_INTERVAL * 1_000_000);
  }
}

eval_main_loop();
